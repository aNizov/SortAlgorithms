using System;
using System.Collections.Generic;

namespace ANSortAlgorithms
{
	public static partial class SortAlgorithms
    {
		/// <summary>
		/// Имплементация алгоритма сортировки вставкой. Сортировка по возрастанию.
		/// </summary>
		/// <returns>Отсортированный IList</returns>
		/// <param name="array">IList к сортировке</param>
		public static IList<T> InsertionSort<T>(IList<T> array) where T : IComparable
		{
			for (int j = 1; j < array.Count; j++)
			{
				//Выбираем ключевой элемент
				T key = array[j];

				//Находим индекс с левой стороны от индекса ключевого элемента
				int i = j - 1;

				//до тех пор пока не достигнута граница массива или левый элемент станет меньше чем правый элемент
				while (i >= 0 && array[i].CompareTo(key) > 0)
				{
					//... сдвигаем левый элемент на одну позицию вправо, затирая левый элемент
					//значение левого элемента уже скопировано в ключевое значение
					array[i + 1] = array[i];
					//...после сдвига выбираем индекс следующего левого элемент
					i--;
				}
				//Теперь все элементы сдвинуты, слева от ключевого элемента меньший элемент 
				//или достигнут левый конец массива, иначе мы бы не вышли из цикла.
				//но текущий индекс сдвинут влево на единицу (это произошло либо на последней итерации цикла while, либо до цикла while)
				//поэтому возвращаем текущий индекс вправо на одну позицию
				array[i + 1] = key;
			}
			return array;
		}
		/// <summary>
		/// Имплементация алгоритма сортировки вставкой. Сортировка по убыванию.
		/// </summary>
		/// <returns>Отсортированный IList</returns>
		/// <param name="array">IList к сортировке</param>
		public static IList<T> InsertionSortByDescending<T>(IList<T> array) where T : IComparable<T>
		{
			for (int j = 1; j < array.Count; j++)
			{
				//Выбираем ключевой элемент
				T key = array[j];

				//Находим индекс с левой стороны от индекса ключевого элемента
				int i = j - 1;

				//до тех пор пока не достигнута граница массива или левый элемент станет больше чем правый элемент
				while (i >= 0 && array[i].CompareTo(key) < 0)
				{
					//... сдвигаем левый элемент на одну позицию вправо, затирая левый элемент
					//значение левого элемента уже скопировано в ключевое значение
					array[i + 1] = array[i];
					//...после сдвига выбираем индекс следующего левого элемент
					i--;
				}
				//Теперь все элементы сдвинуты, слева от ключевого элемента меньший элемент 
				//или достигнут левый конец массива, иначе мы бы не вышли из цикла.
				//но текущий индекс сдвинут влево на единицу (это произошло либо на последней итерации цикла while, либо до цикла while)
				//поэтому возвращаем текущий индекс вправо на одну позицию
				array[i + 1] = key;
			}
			return array;
		}
	}
}
